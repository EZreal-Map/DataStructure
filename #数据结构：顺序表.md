# 1数据结构：线性表

## 1、顺序线性表

![顺序线性表](https://github.com/EZreal-Map/DataStructure/blob/main/image/1689772680273.png)

### 1.1、线性表主函数测试文件 

~~~C++
#include <iostream>
#include "SeqList.h"

using namespace std;


int main(){
	SeqList<int> mylist({1,2,3,4,5});
	mylist.display();
    // 获取元素
	cout << "获取元素：" << mylist.get(3) << endl << endl;
	// 插入元素
	mylist.insert(2, 100);
	mylist.display(); 
	// 删除元素
	mylist.del(5);
	mylist.display();
}
~~~

### 1.2、线性表类（class SeqList）声明与定义头文件——SeqLis.h

```c++
// SeqList.cpp
#ifndef SEQLIST_H
#define SEQLIST_H
#include <iostream>
using namespace std;
const int MAXSIZE = 100;

template<typename ElemType>
class SeqList {
private:
	ElemType datas[MAXSIZE]; /*数组 存储数据元素*/
	int length;				 /*线性表当前长度*/
public:
	/*构造函数*/
	SeqList(std::initializer_list<ElemType> datas);
	/*1、获取元素*/
	ElemType get(int num);

	/*2、插入元素*/
	void insert(int num, ElemType data);

	/*3、 删除元素*/
	void del(int num);

	/*4、 遍历显示元素*/
	void display();
};


template<typename ElemType>
SeqList<ElemType>::SeqList(std::initializer_list<ElemType> datas) {
	/*std::initializer_list 是 C++ 中的一个模板类，
		它提供了一种方便的方式来创建初始化列表，允许在构造函数或函数参数中传递一组值。*/
	this->length = 0;
	for (ElemType data : datas) {
		this->datas[this->length++] = data;
	}
}
/*1、获取元素*/
template<typename ElemType>
ElemType SeqList<ElemType>::get(int num) {
	if (num<1 || num>this->length) {
		cout << "超过线性表" << endl;
		return 0;
	}
	else {
		return this->datas[num - 1];
	}

}

/*2、插入元素*/
template<typename ElemType>
void SeqList<ElemType>::insert(int num, ElemType data) {
	if (num<1 || num>this->length + 1) {
		cout << "超过线性表" << endl;
	}
	else {
		++(this->length);
		--num;
		for (int i = this->length; i > num; --i) {
			this->datas[i] = this->datas[i - 1];
		}
		this->datas[num] = data;
	}
}

/*3、 删除元素*/
template<typename ElemType>
void SeqList<ElemType>::del(int num) {
	if (num<1 || num>this->length) {
		cout << "超过线性表" << endl;
	}
	else {
		--(this->length);
		--num;
		for (int i = num; i < this->length; ++i) {
			this->datas[i] = this->datas[i + 1];
		}
	}
}

/*4、 遍历显示元素*/
template<typename ElemType>
void SeqList<ElemType>::display() {
	for (int i = 0; i < this->length; ++i) {
		cout << "顺序线性表长度为[" << this->length << "], 其中第[" << i + 1 << "]个元素为：" << datas[i] << endl;
	}
	cout << endl;
}
#endif // SEQLIST_H
```

> 补充:[C++模板的声明和定义为什么不能分写在.h与.cpp文件中？](url https://www.cnblogs.com/JCpeng/p/15072692.html)
>
> 将模板的声明和定义都放置在同一个.h文件中。这同时也是为什么所有的STL头文件都包含模板定义的原因。

### 1.3 使用C++标准库容器`vector`的动态数组功能

#### 1.3.1 定义和初始化vector对象

|           语法           |                         功能                          |
| :----------------------: | :---------------------------------------------------: |
|       vector<T> v1       | v1是一个空vector，它潜在的元素是T类型，执行默认初始化 |
|     vector<T> v2(v1)     |               v2中包含v1所以元素的副本                |
|    vector<T> v2 = v1     |        等价于v2(v1)，v2中包含v1所以元素的副本         |
| ==vector<T> v3(n, val)== |    ==v3包含了n个重复的元素，每个元素的值都是val==     |
|   ==vector<T> v4(n)==    |       ==v4包含了n个重复地执行了值初始化的对象==       |
|  vector<T> v5{a,b,c...}  | v5包含了初始化个数的元素，每个元素被赋予相应的初始值  |
| vector<T> v5={a,b,c...}  |                  等价于v5{a,b,c...}                   |

#### 1.3.2 vector的操作

| 方法               | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| v.empty()          | 如果v不含有任何元素，返回真；否则返回假                      |
| ==v.size()==       | ==返回v中元素的个数==                                        |
| ==v.push_back(t)== | ==向v的尾端添加一个值为t的元素==                             |
| ==v.pop_back()==   | ==在末尾弹出一个元素==                                       |
| v[n]               | 返回v中第n个位置上元素的引用                                 |
| v1 = v2            | 用v2中元素的拷贝替换v1中的元素                               |
| v1 = {a,b,c...}    | 用列表中元素的拷贝替换v1中的元素(std::initializer_list<T>)   |
| v1 == v2           | v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| v1 != v2           |                                                              |
| <, <=, >, >=       | 顾明思义，以字典顺序进行比较                                 |

#### 1.3.3 标准容器迭代器的运算符

| 语法                                        | 功能                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| ==vector<int>::iterator it_b = v.begin();== | ==begin成员负责返回指向第一个元素的迭代器==                  |
| vector<int>::iterator it_e = v.end();       | end成员                          最后一个元素                |
| ==*iter==                                   | ==返回迭代器iter所指元素的引用==                             |
| ==iter->mem==                               | ==解引用iter并获取该元素的名位mem的成员，等价与(*iter).mem== |
| ==++iter==                                  | ==令iter指示容器中的下一个元素==                             |
| --iter                                      | 上一个元素                                                   |
| iter+n                                      | 迭代器加上一个整数仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指向指示容器尾元素的下一个位置 |
| iter-n                                      |                                                              |
| iter+=n                                     | iter = iter+ n;                                              |
| iter1-iter2                                 | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器 |
| >、>=、<、<=                                | 比较前后iter1、iter2                                         |

